use super::map::{carmack_expand, rlew_expand};

// First test case from: https://moddingwiki.shikadi.net/wiki/Carmack_compression
// others are from: https://github.com/camoto-project/gamecompjs/blob/master/test/test-cmp-carmackize.js
#[test]
pub fn test_carmack_expand() {
	let cases = vec![
		("0 count example", 
			vec![0x00, 0xA7, 0x12, 0xEE, 0xFF, 0x00, 0xA8, 0x34, 0xCC, 0xDD], 
			vec![0x12, 0xA7, 0xEE, 0xFF, 0x34, 0xA8, 0xCC, 0xDD]),
		("near ptr before eof",
			vec![0x78, 0x56, 0x34, 0x12, 0x02, 0xA7, 0x02, 0x00, 0x01],
			vec![0x78, 0x56, 0x34, 0x12, 0x78, 0x56, 0x34, 0x12, 0x00, 0x01]),
		("near ptr at eof",
			vec![0x78, 0x56, 0x34, 0x12, 0x02, 0xA7, 0x02],
			vec![0x78, 0x56, 0x34, 0x12, 0x78, 0x56, 0x34, 0x12]),
		("far pointer before EOF",
			vec![0x78, 0x56, 0x34, 0x12, 0x00, 0x01, 0x00, 0x03, 0x02, 0xA8, 0x01, 0x00, 0x00, 0x01],
			vec![0x78, 0x56, 0x34, 0x12, 0x00, 0x01, 0x00, 0x03, 0x78, 0x56, 0x34, 0x12, 0x00, 0x01]),
		("far pointer at EOF",
			vec![0x78, 0x56, 0x34, 0x12, 0x00, 0x01, 0x00, 0x03, 0x02, 0xA8, 0x01, 0x00],
			vec![0x78, 0x56, 0x34, 0x12, 0x00, 0x01, 0x00, 0x03, 0x78, 0x56, 0x34, 0x12]),
		("escape near pointer",
			vec![0x78, 0x56, 0x34, 0x12, 0x00, 0xA7, 0x55, 0x00,0x01],
			vec![0x78, 0x56, 0x34, 0x12, 0x55, 0xA7, 0x00, 0x01]),
		("escape near pointer at EOF",
			vec![0x78, 0x56, 0x34, 0x12, 0x00, 0xA7, 0x55],
			vec![0x78, 0x56, 0x34, 0x12, 0x55, 0xA7]),
		("escape far pointer",
			vec![0x78, 0x56, 0x34, 0x12, 0x00, 0xA8, 0x55, 0x00, 0x01],
			vec![0x78, 0x56, 0x34, 0x12, 0x55, 0xA8, 0x00, 0x01]),
		("escape far pointer at EOF",
			vec![0x78, 0x56, 0x34, 0x12, 0x00, 0xA8, 0x55],
			vec![0x78, 0x56, 0x34, 0x12, 0x55, 0xA8]),
		("repeat word three times",
			vec![0x78, 0x56, 0x34, 0x12, 0x02, 0xA7, 0x02, 0x02, 0xA7, 0x02, 0x00, 0x01, 0x00, 0x01],
			vec![0x78, 0x56, 0x34, 0x12, 0x78, 0x56, 0x34, 0x12, 0x78, 0x56, 0x34, 0x12, 0x00, 0x01, 0x00, 0x01]),
		("incomplete word at EOF",
			vec![0x78, 0x56, 0x34, 0x12, 0x02, 0xA7, 0x02, 0x00, 0x01, 0x55],
			vec![0x78, 0x56, 0x34, 0x12, 0x78, 0x56, 0x34, 0x12, 0x00, 0x01, 0x55]),
	];

	for (desc, compressed, decompressed) in cases {
		let result = carmack_expand(&compressed, decompressed.len());
		assert_eq!(result, decompressed, "{}", desc);
	}
}

// test cases from: https://github.com/camoto-project/gamecompjs/blob/master/test/test-cmp-rlew-id.js
#[test]
pub fn test_rlew_expand() {

	let byte_count = 65535 * 2;
	let mut words64k = Vec::with_capacity(byte_count);
	for _ in 0..byte_count {
		words64k.push(0x55);
	}

	let cases = vec![
		("RLE trigger is escaped at EOF", 
			vec![0x34,0x12, 0xFE,0xFE, 0x01,0x00, 0xFE,0xFE],
			vec![0x34,0x12, 0xFE,0xFE],
			0xFEFE),
		("RLE trigger is escaped with trailing data", 
			vec![0x34,0x12, 0xFE,0xFE, 0x01,0x00, 0xFE,0xFE, 0x00,0x00],
			vec![0x34,0x12, 0xFE,0xFE, 0x00,0x00],
			0xFEFE),
		("RLE ignores two-word sequences", 
			vec![0x34,0x12, 0xAA,0xAA, 0xAA,0xAA],
			vec![0x34,0x12, 0xAA,0xAA, 0xAA,0xAA],
			0xFEFE),
		("RLE processes four-word sequences", 
			vec![0x34,0x12, 0xFE,0xFE, 0x04,0x00, 0xAA,0xAA],
			vec![0x34,0x12, 0xAA,0xAA, 0xAA,0xAA, 0xAA,0xAA, 0xAA,0xAA],
			0xFEFE),		
		("RLE works on trigger byte", 
			vec![0x34,0x12, 0xFE,0xFE, 0x04,0x00, 0xFE,0xFE],
			vec![0x34,0x12, 0xFE,0xFE, 0xFE,0xFE, 0xFE,0xFE, 0xFE,0xFE],
			0xFEFE),
		("RLE of 64k words is split with non-RLE trailer",
			vec![0x34,0x12, 0xFE,0xFE, 0xFF,0xFF, 0x55,0x55, 0x34,0x12],
			combine(&vec![0x34,0x12], &words64k, &vec![0x34,0x12]),
			0xFEFE),
		("RLE of 64k+1 words is split with RLE trailer",
			vec![0x34,0x12, 0xFE,0xFE, 0xFF,0xFF, 0x55,0x55, 0x55,0x55, 0x34,0x12],
			combine(&vec![0x34,0x12], &words64k, &vec![0x55,0x55, 0x34,0x12]),
			0xFEFE),
		("ending with RLE-escape works",
			vec![0x34,0x12, 0xFE,0xFE, 0x01,0x00, 0xFE,0xFE],
			vec![0x34,0x12, 0xFE,0xFE],
			0xFEFE),
		("different RLE trigger works",
			vec![0x34,0x12, 0xCD,0xAB, 0x04,0x00, 0xAA,0xAA],
			vec![0x34,0x12, 0xAA,0xAA, 0xAA,0xAA, 0xAA,0xAA, 0xAA,0xAA],
			0xABCD),
		("incomplete word at EOF",
			vec![0x34,0x12, 0xAA,0xAA, 0xAA,0xAA, 0x55],
			vec![0x34,0x12, 0xAA,0xAA, 0xAA,0xAA, 0x55],
			0xFEFE),
		("incomplete word at EOF in the middle of a repeat",
			vec![0x34,0x12, 0xFE,0xFE, 0x04,0x00, 0xAA,0xAA, 0xAA],
			vec![0x34,0x12, 0xAA,0xAA, 0xAA,0xAA, 0xAA,0xAA, 0xAA,0xAA, 0xAA],
			0xFEFE),
	];

	for (desc, compressed, decompressed, tag) in cases {
		let result = rlew_expand(&compressed, decompressed.len(), tag);
		assert_eq!(result.len(), decompressed.len());
		assert_eq!(result, decompressed, "{}", desc);
	}	
}

// helper

fn combine(vec1: &Vec<u8>, vec2: &Vec<u8>, vec3: &Vec<u8>) -> Vec<u8> {
	let mut result = Vec::with_capacity(vec1.len()+vec2.len()+vec3.len());
	for i in 0..vec1.len() {
		result.push(vec1[i]);
	}

	for i in 0..vec2.len() {
		result.push(vec2[i]);
	}

	for i in 0..vec3.len() {
		result.push(vec3[i])
	}

	result
}